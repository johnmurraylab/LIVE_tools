#' CD_Processing
#' This file contains several utility functions that process data based on from CD phenotying file pipelines
#' mainly handle the input of CD files by whole directory


#' CD_In:
#' @description
#' Function to batch import embryo data
#'
#' @param directory directory the directory (folder) directly embryo cell tracking files
#' @param prefix prefix to identify embryo cell tracking files
#' @param suffix suffix (including file format) to identify embryo cell tracking files
#' @param info.prefix prefix to identify embryo info files
#' @param info.suffix suffix (including file format) to identify embryo info files
#' @param time.prefix prefix to identify embryo imaging time record files
#' @param time.suffix suffix (including file format) to identify embryo imaging time record files
#'
#' @return a large list made of:
#'        CD: a list of Dataframes created by reading each embryo cell tracking file
#'        info: a list of Dataframes each recoding informations of corresponding embryos
#' @export
CD_In<-function(directory, prefix = "", suffix = ".csv",
                info.prefix = "", info.suffix = NULL,
                time.prefix = "", time.suffix = NULL){
  CD.term = paste0("^",prefix,".+",suffix,"$")
  info.term <- paste0("^",info.prefix,".+",info.suffix,"$")
  time.term <- paste0("^",time.prefix,".+",time.suffix,"$")
  files <- list.files(directory)
  info.files <- grep(info.term, files, value = F)
  time.files <- grep(time.term, files, value = F)
  CD.files <- grep(CD.term,files,value = F)
  if(all(info.files%in%CD.files)){CD.files <- CD.files[!CD.files%in%info.files]}
  if(all(time.files%in%CD.files)){CD.files <- CD.files[!CD.files%in%time.files]}
  CD.files <- files[CD.files]
  embNames <- gsub(paste0("^",prefix,"(.+)",suffix,"$"), "\\1", CD.files)
  CDDataL <- list()
  CDDataL[['CD']] <- list()
  if(!is.null(info.suffix)){
    info.path <- paste0(directory,info.prefix,embNames,info.suffix)
    embryos.Info <- list()
    embryos.Info <- lapply(info.path, function(this.path){
      this.info <- read.csv(this.path, header = T)
      if(!"depth_corrected"%in%names(this.info)){this.info[,"depth_corrected"] <- F}
      if(!is.null(time.suffix)){this.info[,"time_corrected"] <- T}
      else if(!"time_corrected"%in%names(this.info)){this.info[,"time_corrected"] <- F}
      if(!"rotated"%in%names(this.info)){this.info[,"rotated"] <- F} #can add more to record rotation parameters
      this.info
    })
    names(embryos.Info) <- embNames
    CDDataL[['info']] <- embryos.Info
  }
  else{
    CDDataL[['info']] <- data.frame(emb = embNames, name = embNames)
  }
  CDDataL[['CD']] <- list()
  for (emb in embNames) {
    CD.Path <- paste0(directory,prefix,emb,suffix)
    if(!is.null(time.suffix)){time.file <- paste0(directory, time.prefix, emb, time.suffix)}
    else{time.file<-NULL}
    read_out <- readEmbryoTable(CD.Path, time.file)
    CDDataL[['CD']][[emb]] <- read_out[[1]]
    CDDataL[['info']][[emb]][,"time_corrected"] <- CDDataL[['info']][[emb]][,"time_corrected"] || read_out[[2]]
  }
  names(CDDataL[['CD']]) <- embNames

  return(CDDataL)
}

#' CD_Save
#' @description
#' save cell tracking files along with the
#'
#' @param CDDataL the list of CD Data generated by function `CD_In`
#' @param saveDir directory to output the tables and info file
#'
#' @export
CD_Save <- function(CDDataL, saveDir){
  embryos <- names(CDDataL[["CD"]])
  if(substr(saveDir, start = nchar(saveDir), stop = nchar(saveDir))!="/"){
    saveDir <- paste0(saveDir, "/")
  }
  for (embryo in embryos) {
    CD.file <- paste0(saveDir, "CD", embryo, ".csv")
    write.csv(CDDataL[["CD"]][[embryo]], CD.file, row.names = FALSE)
  }
  for (embryo in embryos) {
    info.file <- paste0(saveDir, embryo, "Info.csv")
    write.csv(CDDataL[["info"]][[embryo]], info.file , row.names = FALSE)
  }
}

#' trimCD
#' @description
#' drop the provided columns from all imported CD data
#'
#' @param CDDataL the list of CD Data generated by function `CD_In`
#' @param drops names of columns to drop
#'
#' @export
#' @return the CDDataL
trimCD <- function(CDDataL, drops){
  CDDataL[['CD']] <- lapply(CDDataL[['CD']], function(L){L[,!names(L) %in% drops]})
  return(CDDataL)
}



#' plotBlotLine
#' @description
#' plots the averaged blot value across each timepoint for selected cells/lineages from all CD data available
#' @param CDDataL the list of CD Data generated by function `CD_In`
#' @param alignCell the cell used to find common time point to align across embryos
#' @param cells (list of) exact cell names to extract
#' @param lineages (list of) mother cell names of lineages to extract
#' @param excludeCD (list of) CD names to exclude
#' @param colorGroup the embryo attribute by which we assign color to its corresponding figure curve, use embryo name by default
#' @param color_palette a named vector that map each possible colorGroup value to a color, use NULL to autogenerate a color palette by colorGroup
#' @param xrange a list in format list(min,max) to define range of x axis
#' @param yrange a list in format list(min,max) to define range of y axis
#' @return a single plotly line plot with each line the (average) blot vs time for each embryo
#' @export
#' @import RColorBrewer
#' @import plotly
plotBlotLine <- function(CDDataL, title, aligningCell, align_t = "mean",
                         cells=NULL, lineages=NULL, excludeCD = NULL,
                         colorGroup = "name", color_palette = NULL,
                         xrange = list(NULL, NULL), yrange = list(NULL, NULL)){
  embNames <- names(CDDataL[["CD"]])
  color_by <- colorGroup
  if(colorGroup=="name"){colorGroup <- embNames}
  else{colorGroup <- embNames|>lapply(function(name){
      CDDataL[["info"]][[name]][1,colorGroup]})
  }
  blotData <- getCells(CDDataL, includeCD = embNames, cells = cells, lineages = lineages, excludeCD = excludeCD)
  if(align_t!="NO"){
    blotData <- blotData|>
      alignTime(alignCell = aligningCell, alignBlot = "mean", align_t = align_t)
  }
  blotData <- blotData|>lapply(timeAvg, attribute = "blot")
  fig <- plotly::plot_ly()
  if(!color_palette|>is.character()){#generate a color palette if none is delivered
    unique_colors <- unique(colorGroup)
    color_palette <- colorRampPalette(
      RColorBrewer::brewer.pal(9, "RdBu"))(length(unique_colors))|>
      setNames(unique_colors)
  }
  for(i in seq_along(blotData)){
    traceName <- embNames[i]
    colorThis <- colorGroup[i]
    if(color_by!="name"){traceName=paste0(colorThis, " ", traceName)}
    fig <- fig|>plotly::add_trace(data = blotData[[i]], x = ~time, y = ~blot,
                          type = 'scatter', mode = 'lines',
                          name = traceName,
                          line = list(color = color_palette[colorThis]),
                          legendgroup = colorThis)
  }
  fig <- fig|>
    plotly::layout(xaxis = list(title = "Time (min)", range = xrange),
           yaxis = list(title = "Blot", range = yrange),
           annotations = list(text = title,
                              xref = "paper", yref = "paper", yanchor = "bottom", xanchor = "center",
                              align = "center", x = 0.5, y = 1, showarrow = FALSE)
    )
  return(fig)
}

#' getCells
#' @description
#' extract the data of given cells from each CD file
#'
#' @param CDDataL the list of CD Data generated by function `CD_In`
#' @param includeCD the embryos/CD file name to be extracted
#' @param excludeCD the embryos/CD file name to be avoid (will override `include`)
#' @param cells (list of) exact cell names to extract
#' @param lineages (list of) mother cell name of lineage to extract
#' @param dataReturn whether this function return the data (TRUE) or index (FALSE) of selected cells
#' @return a list of dataframes with the cell data, indexed by CD file embryo names
#' @export
getCells <- function(
    CDDataL, includeCD = NaN, excludeCD = NULL, cells=NULL, lineages=NULL, times = "ALL", dataReturn = TRUE){
  if (!is.character(includeCD)) {includeCD<-names(CDDataL[['CD']])}
  embryos <- setdiff(includeCD, excludeCD) #exclude have higher priority than include
  CDs <- CDDataL[["CD"]][embryos]
  CDs <- CDs %>% lapply(grepCells, cells=cells, lineages=lineages, times=times, dataReturn = dataReturn)
  CDs|>setNames(embryos)
  return(CDs)
}



#' depthCorrectionParm:
#' @description
#' get the depth (`z`) correction parameters based on the sample data with an exponential model: \cr
#' `blot = blotReal * (exp(a*z) * b)` (1) for `a` and `b` are factors to be determined\cr
#' `blot/blotReal = exp(a*z) * b` (2) \cr
#' `ln(blot/blotReal) = a*z + b` (3) \cr
#' Assuming the real blot is the same across cells at the same timepoint (after aligning development stages), we
#' will make the mean of the same cell for each timepoint the `blotReal`
#'
#' @param CDDataL the list of CD Data generated by function `CD_In`
#' @param cells array of cell names to be considered for depth correction
#' @param lineages array of lineages mother cell names to be considered for depth correction
#' @param alignAt the cell name by which all embryo time will be aligned at its end, and its end time will become 0 after alignment
#' @param startT time after alignment (as frame number), only data after this time point will be considered in fitting model
#' @param endT time after alignment (as frame number), only data before this time point will be considered
#' @param exc_zMin excitation at z=1
#' @param exc_zMax excitation at maximum z
#' @param zMax maximum z
#' @return the regression model from fitting
#' @export
#' @import dplyr
depthCorrectionParm <- function(
    CDDataL, cell=NULL, lineage=NULL, alignCell, startT=0, endT=Inf, exc_zMin, exc_zMax, zMax){
  excStep_z <- (exc_zMax - exc_zMin)/zMax
  CDDataL <- CDDataL|>trimCD(c("none", 'global', 'gweight', 'size', 'cellTime', 'x', "y"))
  controlblots <- CDDataL[["CD"]]|> #increase all blotvalues by a baseline to make most values > 0
    lapply(function(df){min(df$blot)}) |> unlist() |> mean()
  cellsToFit <- CDDataL |>
    getCells(cells = cell, lineages = lineage)
  embryoNames <- names(cellsToFit)
  cellsToFit <- embryoNames|>
    lapply(function(embryo){
      df <- cellsToFit[[embryo]]
      df$blot <- df$blot - controlblots
      df[df$blot<=10, 'blot'] <- 10
      df$blot <- df$blot/((df$z-1)*excStep_z+exc_zMin) #correct for excitation
      if(CDDataL[["info"]][[embryo]][1,"time_corrected"]){
        df$time <- df$time%/%1.5} #bundle cell times into 1.5minute bins
      df})
  names(cellsToFit)<-embryoNames
  cellsToFit <- alignTime(cellsToFit, alignCell = alignCell, align_t = 0)
  dataToFit <- cellsToFit|>
    aggEmbryos(labelEmbryo = F)|>
    dplyr::select(c("cell","time","z","blot"))
  blotByDepth <- dataToFit[dataToFit$time>=startT & dataToFit$time<=endT,]|>
    group_by(time, cell)|>dplyr::mutate(blot = blot/mean(blot))|>
    group_by(time, z)|>dplyr::summarize(blot = mean(blot))
  model <- lm(log(blot)~z,data = blotByDepth)
  return(model)
}

#' dataCorrection
#' @description
#' apply the data correction parameters generated by `depthCorrectionParm` to do correction
#'
#'
#' @param CDDataL the list of CD Data generated by function `CD_In`
#' @param cell only correct some specific cells
#' @param lineage only correct some specific lineages
#' @param alignAt the cell used to find common time point to align
#' @param model the model generated by `depthCorrectionParm`
#' @param exc_zMin excitation at z=1
#' @param exc_zMax excitation at maximum z
#' @param zMax maximum z
#'
#' @return corrected `CDDataL`
#' @export
dataCorrection <- function(
    CDDataL, cell=NULL, lineage="P0", alignAt=NaN, model, exc_zMin, exc_zMax, zMax){
  excStep_z <- (exc_zMax - exc_zMin)/zMax
  meanExc <- (exc_zMin+exc_zMax)/2
  factorA <- model[["coefficients"]][["z"]]
  factorB <- model[["coefficients"]][["(Intercept)"]]
  dataIndex <- CDDataL|>getCells(cells = cell, lineages = lineage, dataReturn = F)
  embryos <- names(CDDataL[["CD"]])

  controlblots <- CDDataL[["CD"]]|>
    lapply(function(df){min(df$blot)})
  baseBlot <- mean(unlist(controlblots))
  CDDataL[["CD"]] <- embryos|>lapply(function(embryo){
    df <- CDDataL[["CD"]][[embryo]]
    thisCells <- dataIndex[[embryo]]
    minBlot <- df$blot |> min()
    df$blot <- df$blot - baseBlot
    df[df$blot<=1, 'blot'] <- 1
    excitation <- (df[thisCells,'z']-1)*excStep_z+exc_zMin
    depthFactor <- exp(df[thisCells,'z']*factorA+factorB)
    df[thisCells,'blot'] <- df[thisCells,'blot']/depthFactor/excitation*meanExc
    df
  })
  names(CDDataL[["CD"]]) <- embryos
  if(is.character(alignAt)){
    CDDataL[["CD"]] <- CDDataL[["CD"]]|>alignTime(alignCell = alignAt, alignBlot = "mean")}
  for (embryo in embryos) {
    CDDataL[["info"]][[embryo]][1,"depth_corrected"] <- T
  }
  return(CDDataL)
}


#' findCell
#' @description
#' return the occurrence of a cell name from the list generated by `CD_In`
#'
#' @param CDDataL list returned by `CD_In`
#' @param cellName name of the cell
#'
#' @return a list of dataframes recording all instances of the cell';s occurrence
#' @export
findCell <- function(CDDataL, cellName){
  out <- lapply(CDDataL[["CD"]], function(L){L[L$cell==cellName,]})
  out
}

#' Emb_drop
#' @description
#' Remove an embryo data from the list generated by `CD_In`
#'
#' @param CDDataL the list generated by `CD_In`
#' @param dropEmb names of embryos todrop
#'
#' @return dropped `CDDataL`
#' @export
Emb_drop <- function(CDDataL, dropEmb=NaN){
  embryoNames <- names(CDDataL[["CD"]])
  embryoNames <- embryoNames[!embryoNames %in% dropEmb]
  CDs <- CDDataL[["CD"]][embryoNames]
  embInfo <- CDDataL[["info"]][embryoNames]
  newDat[["CD"]] <- CDs
  newDat[["info"]] <- embInfo
  return(newDat)
}
